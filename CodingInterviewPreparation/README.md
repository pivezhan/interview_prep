### Fundamentals

During today's session covering how to apply fundamental computer science concepts to analyze and explain coding problems in an interview context, we focused on:

* **Binary Systems Application** : You demonstrated a solid understanding of why computers use binary, how to represent decimal numbers in binary, and the effect of bitwise operations like left-shifting.
* **Big-O Analysis Practice** : You accurately explained what Big-O notation represents and correctly identified the time complexities for linear search (O(n)) and binary search (O(log n)), along with the reasoning behind them.
* **Time vs Space Trade-offs** : You clearly articulated the meaning of time-space trade-offs and provided an excellent example using arrays, vectors, and linked lists to illustrate how different data structures balance memory usage and operational speed.

**Your strengths:**

* Strong grasp of core computer science concepts, including binary representation and Big-O notation.
* Ability to articulate reasoning clearly and connect concepts to practical scenarios.
* Excellent understanding of the trade-offs involved in choosing different data structures.

**Areas for improvement:**

* Continue practicing explaining these concepts aloud to further refine your communication for interview settings.
* Explore more complex examples of time-space trade-offs in various algorithms.

Keep up the good work!

### STAR Method

* Situation (projects and challenges faced)
* Task (your responsibilities and assignments)
* Action (actions required to rectify or address the challenges)
* Result (the outcomes of your challenges)

### Data Structure

* Models an object that can be stored in memory
* Classified into linear(lists, dictionaries, heaps, linked list) and non-linear (trees and graphs)
* Mutable vs immutable data sctructures (mutable like )

### Lists vs Sets

* Lists have two forms of arrays and linked list and are for storing ordered elements (order means it retain the order of items as they are inserted)
  * orders remain (orders when inserted remain)
  * different types can be added
  * search is more arduous
  * can consist of mutable and immutable as their content can change
* Sets are for storage of unordered elements
  * sets do not have order
  * different types cannot be added
  * can consist of mutable and immutable
  * search is easier
  * cannot have duplicates

### Stacks and Queues

* lists and arrays allow random access and list and queues allow sequential access
* Stacks are linear data structure with FILO (First in Last out) basis
  * Push, Pop, isEmpty, isFull, Peek
    * Peek allows looking into the top item in stack without removing it from stack
* Queues are linear data with FIFO (First in First out) basis
  * Front(pop), Back(insert)
